1) NestJS(백엔드)에 필요한 기능

(A) 게임(점수판) 상태를 관리하는 로직

1. 게임 모드 & 세트 설정
단식/복식 여부를 저장(“singles”, “doubles”)하고, 해당 모드에 따라 팀원이 1명인지 2명인지 관리.
한 경기에서 사용할 세트수(3판2선승, 5판3선승, 7판4선승 등)를 설정해 보관.

2. 팀/선수 정보 관리
단식이면 각 팀에 1명, 복식이면 각 팀에 2명의 이름을 저장한다(“홈팀” “어웨이팀”에 해당).
팀명(또는 개인 이름)을 입력받아 내부적으로 저장.

3. 현재 진행 중인 세트 & 점수
각 팀의 현재 세트 점수, 그리고 각 세트 내의 득점(점수A, 점수B)을 관리.
서브권이 누구에게 있는지, 그리고 듀스 여부(10:10 동점 이후 2점 차이 발생 시 세트 종료)를 결정하는 로직.

4. 게임 시간(세트별로 측정) & 기록
게임시작 시점에 시간을 기록하고, 세트가 끝날 때까지 경과한 시간을 저장(또는 실시간으로 계산).
다음 세트를 시작하면 시간을 다시 0초부터 측정(혹은 새로 측정)해서 관리.
최종승자가 결정될 때 전체 소요 시간 기록.

5. 세트 승리 및 최종 승리 판정
한 세트에서 11점 도달(단, 10:10인 경우 듀스)하면 세트 승자 결정.
주어진 세트수(예: 3판2선승) 중 먼저 해당 승수에 도달하면 최종 승리자 결정.
세트가 끝날 때 “홈팀 정보 vs 어웨이팀 정보”를 바탕으로 자동으로 좌우를 교체하고(팀 정보를 스왑), 서브권 이동.

6. 점수 내역(히스토리) 관리
“언제 어느 팀이 몇 점을 땄는지”를 기록해서 맨 아래 점수 현황판에 표시.
세트가 끝나면 현황판은 초기화하거나, 누적 기록을 어느 정도까지 보관할지도 결정. (기본은 한 세트 끝나면 초기화)

7. 전부 끝나면 초기화
최종 승자가 결정된 후, “게임종료” 시 전체 정보(모드, 세트수, 점수, 선수들 등)를 초기화.

(B) API/Gateway 설계

1. 세팅 / 초기화 관련 API
(1) “경기 설정(세트수, 단식/복식, 팀명/선수이름)”을 받는 API
(2) “게임 시작” API (세트 시작 시점)
(3) “게임종료” API (모든 데이터 초기화)

2. 점수 조작 & 듀스 로직
“홈팀 점수+1”, “어웨이팀 점수+1” 등 API에서 점수를 변경하면, 내부 로직이 “10:10 → 듀스” → “2점 차이 발생 시 세트 승리” 등을 판단.

3. 서브권 배정
“서브권 랜덤” API (홈팀/어웨이팀 중 누가 먼저 서브 시작인지 추첨)
듀스 상황 시, 자동 번갈아 서브권 로직. (번갈 때마다 점수 업데이트 시점에 서브권도 바뀌도록 내부 처리)

4. 실시간 전송
Socket.IO 혹은 WebSocket Gateway를 두어, 점수·세트·서브권·시간 등의 변화가 있을 때마다 “scoreUpdate”를 방송.
클라이언트A(점수판 태블릿)에서는 이 방송을 받아 화면에 즉시 반영.

5. 세트 승리 & 최종 승리
한 세트 끝나면 세트 승리자를 10초간 표기할 수 있도록, “세트가 끝났다” 이벤트를 전송.
최종 승리자가 결정되면 “승리 알림” 이벤트를 전송(누가 이겼고, 총 게임 시간은 얼마였는지).

6. 게임 시간 계산
“게임 시작” API를 호출하면 “현재 시각”을 저장 → 세트 종료 시 “경과 시간” 계산.
다음 세트 시작 시 다시 0초부터 or 누적 시각을 관리.
최종 승리 시, 총 소요 시간을 계산해 브로드캐스트.


2) React Native(프런트엔드)에 필요한 것

(A) 클라이언트A: 점수판(태블릿)

화면 구성:

점수 표시: 홈팀 점수 / 어웨이팀 점수 / 듀스 여부 / 현재 세트 스코어 등 크게 표시
서브권 표시: 파란색 박스로 나타나는데, “현재 서브권이 어느 팀에 있는지”에 따라 왼쪽(홈팀) 또는 오른쪽(어웨이팀)에 표시
시간 표시: 세트 시작 시점부터 흐르는 시간, 세트가 끝나면 멈춤
세트 승리 / 최종 승리 시, 큰 텍스트(“1세트 승리!”, “최종 승리!”) 10초간 표출
점수 현황판: 화면 하단에 “H 0 1 2 3 … / A 0 1 2 …” 형태로 득점 히스토리를 나열. 세트가 끝나면 초기화(또는 다른 방식으로 처리)

실시간 업데이트:

Socket.IO(“scoreUpdate” 이벤트) or Polling
이벤트가 오면 화면 상태를 갱신하여 UI 다시 렌더링
(참고): 이 단말은 읽기 전용. 관리자 기능은 없음.


(B) 클라이언트B: 관리자 앱

화면 & 로직:
1. 경기 설정 화면
단식/복식 선택
세트수 선택 (3판2선승, 5판3선승, 7판4선승 중 하나)
팀명/선수명 입력(단식이면 각 팀 1명, 복식이면 각 팀 2명)
“확인” 누르면 NestJS에 “경기 설정” API 호출

2. 게임 시작 & 시간
“게임 시작” 버튼 → 서버로 요청 보내거나, Socket 이벤트로 알림 → 서버가 시간을 0초부터 흐르게 관리
세트 종료 시 자동 일시정지 → 다음 세트 “시작” 버튼 누르면 다시 0초 또는 이어서 측정

3. 서브권 랜덤 추첨
“서브권 추첨” 버튼 → 서버에서 랜덤 계산 or 클라이언트에서 랜덤 → 그 결과를 서버에 반영(“home” or “away”).
점수판 클라이언트가 “서브권이 어느 쪽인지” 실시간 반영

4. 점수 조작
“홈팀 +1점”, “어웨이팀 +1점”, “-1점” 등 버튼. (오류 수정용 -1)
득점이 들어가면 서버가 듀스, 세트종료 여부, 서브권 자동교체 등을 판단.
득점 히스토리에 기록(누가 몇 점을 어떤 시점에 획득했는지)

5. 세트 종료 시 승리자 알림
각 세트가 끝나면 10초간 “1세트 승리!” 표시, 자동 좌우 스왑, 서브권 이전
관리자는 다음 세트 “게임 시작” 버튼으로 진행

6. 최종 승리
설정한 세트수 승리 요건 달성 시, 최종 승자 알림 (큰 화면)
경기 종료 버튼 → 모든 정보 초기화 & 시작화면(게임 종류 선택 등)으로 되돌아감

7. 기타
점수 현황에서 잘못 올린 점수 삭제 기능
득점이 발생할 때마다 하단에 기록(예: “홈팀 득점: 1~2” 식)
UI는 간단히 버튼 + 텍스트 위주




3) 정리해서 구분

(1) NestJS에서 작성할 기능

1. Score(게임) 상태 모델
mode(singles/doubles), teamA/teamB(선수명 배열), scoreA/scoreB, setScoreA/setScoreB, gameTime, serviceRights, etc.

2. 듀스·서브권 로직
듀스 시 2점 차이 조건, 서브권 번갈아 진행, 세트 종료 판단, 최종 승리 판단

3. 세트 수 관리
3판2선승, 5판3선승, 7판4선승 등
한 세트 끝날 때 setScoreA++ / setScoreB++ → 최종 승자 체크

4. API or Socket
POST /scoreboard/setup(모드/세트수/선수명)
POST /scoreboard/start(세트 시작-> 시간 측정)
PATCH /scoreboard/score(점수 +1/-1)
POST /scoreboard/service-random(서브권 랜덤 결정)
POST /scoreboard/end(게임종료-> 데이터 초기화)

5. 실시간 방송
Socket.IO gateway, scoreUpdate event
세트 종료 시 “setWin” event
최종 승리 시 “finalWin” event


(2) React Native(웹&앱)에서 작성할 것

2-A) 점수판(클라이언트A):
1. 디자인(사진처럼): 큰 숫자로 양팀 점수, 팀명/선수명, 득점 현황, 게임 타이머, 세트 승리/최종 승리 알림 표시

2. 실시간 수신: Socket.IO “scoreUpdate” or 1초 polling
수신 데이터로 “현재 세트 점수, 듀스인지, 서브권 누구인지, 세트별 점수표, 경과 시간” 등을 화면에 반영

3 .승리 화면(10초 표시): 세트 끝나면 “OO세트 승리”, 최종 승자 시 “경기 종료” 등

2-B) 관리자(클라이언트B):
1. 경기 설정화면:
(1) 단식/복식 + 세트수(3,5,7) 선택
(2) 팀명/선수명 입력(단식=1인, 복식=2인)
(3) “확인” 버튼 → 백엔드 API로 전송

2. 게임 시작:
세트 시작 시 시간 카운트 → 백엔드에 “start” 요청
세트 종료 시 자동 stop → 다음 세트 “start” …

3. 서브권 랜덤버튼:
누르면 서버에서 랜덤 결정 or 클라이언트서 랜덤 → 백엔드에 반영

4. 점수 조작:
“홈팀 +1”, “어웨이팀 +1”, “(잘못올렸으면) -1” 버튼들
득점 발생 시 -> 백엔드에 PATCH 요청, 히스토리에 기록

5. 세트 끝 → 10초 승리자 알림:
백엔드로부터 “이 세트 승자는 O팀” 이벤트/응답 받으면, 관리자 화면도 알림 표시 or 그냥 알고만 있음
다음 세트 시작 or 최종승리 시 게임 종료

6. 최종 승리:
설정 세트수 충족하면, “승리!”
관리자 “게임종료” 버튼 → 모든 데이터 reset → 처음 화면(경기 설정)으로

4) 결론
NestJS에선 “모드/세트수/선수명/점수/서브권/시간/역사” 등 전체 게임 상태를 저장·조작하는 로직과 API, 그리고 실시간 방송(Socket.IO)을 구현한다. 듀스·세트승·최종승 등 탁구 규칙도 여기서 처리.
React Native는 “점수판(읽기 전용)”과 “관리자(설정·점수조작)”로 나뉘어 각각의 UI를 만든다:
클라이언트A: NestJS로부터 실시간 scoreUpdate를 받아 점수·서브권·세트 승리·최종승리 상태를 화면에 표시.
클라이언트B(관리자): 경기 설정(단식/복식, 세트수, 선수명) / 점수업데이트(+1,-1) / 서브권 랜덤 / 세트·최종승 결과 알림 / 경기종료(리셋) 등 기능 구현.
이렇게 하면, 요청하신 사진(디자인)에 맞춰서 태블릿 점수판을 구현하고, 관리자 쪽 앱에서 제어 가능한 구조를 정확히 만들 수 있다.





---------------------------------------------------------------
전체 과정 개요
[1단계] 개발 환경 및 초기 세팅

Node.js, Nest CLI 설치
새 NestJS 프로젝트 생성
MySQL 설치 및 DB 연결(TypeORM 설정)
Socket.IO/real-time 설정을 위해 필요한 패키지 설치
.env 파일 등 환경 변수 세팅

[2단계] 기본 엔티티(Entity) 및 DB 구조 설계

어떤 테이블(엔티티)을 만들지 결정(ScoreBoard, Game, Player 등)
예) scoreboard.entity.ts (id, mode, teamA, teamB, scoreA, scoreB, 등)
TypeORM으로 MySQL과 매핑

[3단계] 비즈니스 로직(ScoreBoard Service) 구현

경기 설정(단식/복식), 세트수/시간/서브권/점수/득점 히스토리/좌우 스왑/듀스 로직 등
DB에 저장·갱신될 때, 해당 로직과 엔티티를 어떻게 연결할지 결정

[4단계] 실시간 통신 (Socket.IO Gateway) 구현

점수나 서브권이 바뀌면 “scoreUpdate” 등 이벤트를 broadcast
점수판(태블릿) 측은 이 이벤트를 수신해 화면 갱신
관리자 측도 필요 시 실시간 상태를 확인

[5단계] API(Controller) 구성

/scoreboard/set-game, /scoreboard/update-score, /scoreboard/reset, /scoreboard/start-game 등
실시간 이벤트와 함께 어떻게 연동할지 결정

[6단계] React Native 클라이언트 구현

A) 점수판(읽기 전용) 화면: Socket.IO 수신 or Polling → 최신 상태 표시
B) 관리자 화면: 경기 설정(모드/세트수/선수), 점수 조작(+1, -1), 서브권 랜덤, 시간측정 등 → NestJS API/Socket 호출

[7단계] 세트·최종승리 로직 + UI 마무리

한 세트 종료 시 10초 표시, 최종승리 시 “경기 끝” 화면, DB에 기록
게임종료 → 초기화
    
[8단계] 배포 및 최종 테스트

Docker나 서버 환경에서 NestJS + MySQL 배포
태블릿/스마트폰에서 React Native 앱 실행 혹은 웹 접근
종합 테스트, 버그 수정
